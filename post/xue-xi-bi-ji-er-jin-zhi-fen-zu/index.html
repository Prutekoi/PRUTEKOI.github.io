<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>[学习笔记]二进制分组 | Prutekoi&#39;s blog</title>
<meta name="description" content="">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://prutekoi.github.io/favicon.ico?v=1576155980067">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://prutekoi.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-153103856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-153103856-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://prutekoi.github.io">
        <img src="https://prutekoi.github.io/images/avatar.png?v=1576155980067" class="site-logo">
        <h1 class="site-title">Prutekoi&#39;s blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://prutekoi.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">[学习笔记]二进制分组</h2>
            <div class="post-date">2019-12-12</div>
            
            <div class="post-content">
              <p>二进制分组处理的问题有这样一些特性:</p>
<ul>
<li>强制在线(离线一般可以CDQ分治)。<s>话说其实觉得二进制分组比CDQ分治好写诶</s></li>
<li>插入和查询。</li>
<li>对应的数据结构不支持增量构建(无法快速插入,只能全局构建)。</li>
</ul>
<p>这种数据结构的例子有很多,如凸包、AC自动机、后缀数组(但后缀数组不适用二进制分组)甚至是主席树。</p>
<p>二进制分组的思想是维护很多组数据结构,适时暴力合并(具体看代码)。时空复杂度为原数据结构乘个log。<br>
合并时最不济就是拿这些元素重新构建一遍,当然一些数据结构可能支持更优秀的合并方式:如凸包归并排序,trie可以类似线段树合并等。</p>
<p>可以顺便解决查询之前某一段操作的影响的问题,只要套上线段树即可。</p>
<p>不支持后缀数组是因为后缀数组的“操作”之间是互相有影响的(字符连成串),所以不能把它们分成好多组。</p>
<h3 id="例题">例题:</h3>
<h4 id="cf710f-string-set-queries">CF710F String Set Queries</h4>
<p>维护一个字符串集合,支持加删字符串,查询集合中串在给定模板串中出现次数和,强制在线。</p>
<p>多字符串匹配问题,可以想到AC自动机,可是AC自动机是先建好trie后bfs构建的,不支持动态插串。这时满足上述提到的问题的性质,可以考虑二进制分组。其实这就是个板子题啦。</p>
<p>不过这题还要支持删除,我们发现我们维护的信息具有可减性,那么我们维护删除掉的串的信息,一减就好啦!</p>
<p>值得一提的是,trie树的合并可以做到很优秀,于是空间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的!</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=6e5+50;
int m,rt[2][30],sz[2][30],c[N][26],tot,cnt[N],sum[N],fail[N],q[N],l,r,num[2],c2[N][26];char s[N];
void build(int d,int x){
	int p=rt[d][x]=++tot;
	for(int i=0;s[i];i++)p=c[p][s[i]-'a']=++tot;
	cnt[p]=1;
}
void merge(int &amp;x,int y){//类似线段树合并
	if(!x||!y){x^=y;return;}
	for(int i=0;i&lt;26;i++)
		merge(c[x][i],c[y][i]);
	cnt[x]+=cnt[y];
}
void getfail(int rt){
	l=1;r=0;
	for(int i=0;i&lt;26;i++)
		if(c[rt][i])fail[c2[rt][i]=q[++r]=c[rt][i]]=rt;
		else c2[rt][i]=rt;//要把原trie上的边保留,因为合并时要用到
	while(l&lt;=r){
		int x=q[l++];sum[x]=sum[fail[x]]+cnt[x];
		for(int i=0;i&lt;26;i++){
			int y=c[x][i],z=c2[fail[x]][i];
			if(y)fail[y]=z,c2[x][i]=q[++r]=y;
			else c2[x][i]=z;
		}
	}
}
int query(int d){
	int ret=0;
	for(int i=1;i&lt;=num[d];i++)
		for(int j=0,p=rt[d][i];s[j];j++)
			ret+=sum[p=c2[p][s[j]-'a']];
	return ret;
}
void change(int d){
	build(d,++num[d]);sz[d][num[d]]=1;
	while(num[d]&gt;1&amp;&amp;sz[d][num[d]]==sz[d][num[d]-1])//其实类似自底向上的线段树
		merge(rt[d][num[d]-1],rt[d][num[d]]),sz[d][--num[d]]*=2;
	getfail(rt[d][num[d]]);
}
int main(){
	scanf(&quot;%d&quot;,&amp;m);
	for(int i=1,op;i&lt;=m;i++){
		scanf(&quot;%d%s&quot;,&amp;op,s);
		if(op==3)printf(&quot;%d\n&quot;,query(0)-query(1)),fflush(stdout);
		else change(op-1);
	}
	return 0;
}
</code></pre>
<h4 id="p3309-sdoi2014向量集">P3309 [SDOI2014]向量集</h4>
<p>维护一个向量集合,支持插入向量,查询第L到第R个插入的向量与给定向量点乘的最大值,强制在线。</p>
<p>首先根据点乘的定义式随便化化式子发现是可以斜率优化的形式,于是转化成了维护凸包。</p>
<p>凸包的随机插入是比较困难的(平衡树?)而且我们发现题目里竟然还有查询第L到第R个这类的字眼,那么二进制分组他不香嘛?于是还是个板子题...</p>
<p>值得一提的是两个凸包合并之后原来的凸包还要留着,所以空间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的。没有区间查询的二进制分组一般可以用垃圾回收等技巧优化空间。</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
#define LL long long
#define pb push_back
using namespace std;
const int N=4e5+50,inf=0x7fffffff;
int n,id[N],xx,yy,m,ql,qr;char S[3],T[3];LL ans;
struct node{
    vector&lt;int&gt;x,y;
    void insert(int xx,int yy){
        int n;
        while((n=x.size()-1)&gt;0&amp;&amp;1ll*(y[n]-y[n-1])*(xx-x[n])&lt;=1ll*(yy-y[n])*(x[n]-x[n-1]))x.pop_back(),y.pop_back();
        x.pb(xx);y.pb(yy);
    }
    void merge(node L,node R){
        int i=0,j=0;
        for(;i&lt;L.x.size()&amp;&amp;j&lt;R.x.size();)
            if(L.x[i]&lt;R.x[j]||L.x[i]==R.x[j]&amp;&amp;L.y[i]&lt;R.y[j])insert(L.x[i],L.y[i]),i++;
            else insert(R.x[j],R.y[j]),j++;
        for(;i&lt;L.x.size();i++)insert(L.x[i],L.y[i]);
        for(;j&lt;R.x.size();j++)insert(R.x[j],R.y[j]);
    }
    LL query(int xx,int yy){
        if(!x.size())return -1e18;
        int l=1,r=x.size()-1,ans=0;
        while(l&lt;=r){
            int mid=(l+r)&gt;&gt;1;
            if(1ll*(y[mid]-y[mid-1])*yy+1ll*(x[mid]-x[mid-1])*xx&gt;=0)ans=mid,l=mid+1;
            else r=mid-1;
        }
        return 1ll*xx*x[ans]+1ll*yy*y[ans];
    }
}t[2][N*4];
void build(int x,int l,int r){
    if(l==r){id[l]=x;return;}
    int mid=(l+r)&gt;&gt;1;
    build(x&lt;&lt;1,l,mid);
    build(x&lt;&lt;1|1,mid+1,r);
}
void add(){
    int x=id[++m];
    t[0][x].x.pb(xx);t[1][x].x.pb(-xx);
    t[0][x].y.pb(yy);t[1][x].y.pb(-yy);
    for(;(x&amp;1)&amp;&amp;x&gt;1;x&gt;&gt;=1)for(int k=0;k&lt;2;k++)
        t[k][x&gt;&gt;1].merge(t[k][x^1],t[k][x]);
}
void query(int x,int l,int r){
    if(l&gt;=ql&amp;&amp;r&lt;=qr){ans=max(ans,yy&gt;0?t[0][x].query(xx,yy):t[1][x].query(-xx,-yy));return;}
    int mid=(l+r)&gt;&gt;1;
    if(ql&lt;=mid)query(x&lt;&lt;1,l,mid);
    if(qr&gt;mid)query(x&lt;&lt;1|1,mid+1,r);
}
int main(){
    scanf(&quot;%d%s&quot;,&amp;n,S);
    build(1,1,n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%s%d%d&quot;,T,&amp;xx,&amp;yy);
        if(S[0]!='E')xx^=ans,yy^=ans;
        if(T[0]=='A')add();
        else{
            scanf(&quot;%d%d&quot;,&amp;ql,&amp;qr);
            if(S[0]!='E')ql^=ans,qr^=ans;
            ans=-1e18;query(1,1,n);
            printf(&quot;%lld\n&quot;,ans);ans&amp;=inf;
        }
    }
    return 0;
}
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://prutekoi.github.io/post/la-ge-lang-ri-fan-yan">
                  <h3 class="post-title">
                    拉格朗日反演
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '7d25e626199673e220e3',
        clientSecret: '18275839c46c0e4e748c553c6a30d28aca3f634a',
        repo: 'Prutekoi.github.io',
        owner: 'Prutekoi',
        admin: ['Prutekoi'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
